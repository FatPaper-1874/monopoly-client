import { ChanceCard as ChanceCardFromDB, GameInfo, GameInitInfo, GameMap, MapItem } from "@/interfaces/game";
import { Player } from "./class/Player";
import { Property } from "./class/Property";
import { User, UserInRoomInfo, GameSetting, SocketMessage } from "@/interfaces/bace";
import { getRandomInteger } from "@/utils";
import { ChanceCardType, GameOverRule, OperateType } from "@/enums/game";
import { ChanceCard } from "./class/ChanceCard";
import { PlayerEvents } from "./enums/game";
import { SocketMsgType } from "@/enums/bace";
import Dice from "./class/Dice";
import { OperateListener } from "./class/OperateListener";
import { WorkerCommMsg } from "@/interfaces/worker";
import { WorkerCommType } from "@/enums/worker";
import { RoundTimeTimer } from "./class/RoundTimeTimer";

const operateListener = new OperateListener();
let gameProcess: GameProcess | null = null;

self.postMessage(<WorkerCommMsg>{
	type: WorkerCommType.WorkerReady,
});

self.addEventListener("message", (ev) => {
	const data: WorkerCommMsg = ev.data;
	switch (data.type) {
		case WorkerCommType.LoadGameInfo:
			{
				const { mapInfo, setting, userList } = data.data;
				gameProcess = new GameProcess(mapInfo, setting, userList);
				gameProcess.start();
			}
			break;
		case WorkerCommType.EmitOperation:
			{
				const { userId, operateType, data: _data } = data.data;
				operateListener.emit(userId, operateType, _data);
			}
			break;
		case WorkerCommType.UserOffLine:
			{
				const { userId } = data.data;
				gameProcess && gameProcess.handlePlayerOffline(userId);
			}
			break;
		case WorkerCommType.UserReconnect:
			{
				const { userId } = data.data;
				gameProcess && gameProcess.handlePlayerReconnect(userId);
			}
			break;
	}
});

function sendToUsers(userIdList: string[], msg: SocketMessage) {
	self.postMessage(<WorkerCommMsg>{
		type: WorkerCommType.SendToUsers,
		data: {
			userIdList,
			data: msg,
		},
	});
}

(async () => {})();

export class GameProcess {
	private mapInfo: GameMap;
	private gameSetting: GameSetting;
	private playerList: Player[] = [];
	private propertyList: Map<string, Property> = new Map();
	private chanceCardInfoList: ChanceCardFromDB[] = [];
	private mapItemList: Map<string, MapItem> = new Map();

	//Dynamic Data
	private isGameOver: boolean = false;
	private currentPlayerInRound: Player | null = null;
	private currentRound: number = 0; //ÂΩìÂâçÂõûÂêà
	private currentMultiplier: number = 1; //ÂΩìÂâçËøáË∑ØË¥πÂÄçÊï∞
	private timeoutList: any[] = []; //ËÆ°Êó∂Âô®ÂàóË°®
	private intervalTimerList: any[] = []; //ËÆ°Êó∂Âô®ÂàóË°®
	private roundTimeTimer: RoundTimeTimer;

	//Setting
	private animationStepDuration_ms: number = 600;

	//Utils
	private dice: Dice;

	constructor(mapInfo: GameMap, gameSetting: GameSetting, users: UserInRoomInfo[]) {
		this.mapInfo = mapInfo;
		this.gameSetting = gameSetting;
		this.dice = new Dice(gameSetting.diceNum);
		this.roundTimeTimer = new RoundTimeTimer(gameSetting.roundTime, 1000);

		this.loadGameMap(mapInfo);
		this.initPlayer(users);
	}

	public async start() {
		this.gameInfoBroadcast();
		this.gameInitBroadcast();

		await this.waitInitFinished();
		await this.gameLoop();
		console.log("Ê∏∏ÊàèÁªìÊùü");
	}

	private loadGameMap(mapInfo: GameMap) {
		const { mapItems, properties, chanceCards } = mapInfo;

		mapItems.forEach((item) => {
			this.mapItemList.set(item.id, item);
		});

		properties.forEach((property) => {
			this.propertyList.set(property.id, new Property(property));
		});

		this.chanceCardInfoList = chanceCards;
	}

	private initPlayer(users: UserInRoomInfo[]) {
		this.playerList = users.map((user) => {
			const player = new Player(
				user,
				this.gameSetting.initMoney,
				getRandomInteger(0, this.mapInfo.indexList.length - 1)
			);

			player.setCardsList(this.getRandomChanceCard(4));

			player.addEventListener(PlayerEvents.SetMoney, () => {
				this.gameOverCheck();
			});

			player.addEventListener(PlayerEvents.Cost, () => {
				this.gameOverCheck();
			});

			player.addEventListener(PlayerEvents.Walk, async (step: number) => {
				const msg: SocketMessage = {
					type: SocketMsgType.PlayerWalk,
					source: "server",
					data: { playerId: player.getId(), step },
				};
				player.setPositionIndex((player.getPositionIndex() + step) % this.mapInfo.indexList.length);
				this.gameInfoBroadcast();
				this.gameBroadcast(msg);

				//Âú®ËÆ°ÂàíÁöÑÂä®ÁîªÂÆåÊàê‰∫ã‰ª∂ÂêéÂèñÊ∂àÁõëÂê¨, Èò≤Ê≠¢ÂÆ¢Êà∑Á´ØÂõ†ÁâπÊÆäÊÉÖÂÜµÊ≤°ÊúâÂèëÈÄÅÂä®ÁîªÂÆåÊàêÁöÑÊåá‰ª§ÈÄ†ÊàêÊ∞∏‰πÖÁ≠âÂæÖ
				const animationDuration = this.animationStepDuration_ms * (this.dice.getResultNumber() + 5);
				let animationTimer = setTimeout(() => {
					operateListener.emit(player.getId(), OperateType.Animation);
				}, animationDuration);
				await operateListener.onceAsync(player.getId(), OperateType.Animation, () => {
					console.log("Êî∂Âà∞Âä®ÁîªÂõûË∞É", Date.now());
					clearTimeout(animationTimer);
				});
				player.emit(PlayerEvents.AnimationFinished);
			});

			player.addEventListener(PlayerEvents.Tp, async (positionIndex: number) => {
				const msg: SocketMessage = {
					type: SocketMsgType.PlayerTp,
					source: "server",
					data: { playerId: player.getId(), positionIndex },
				};
				player.setPositionIndex(positionIndex);
				this.gameInfoBroadcast();
				this.gameBroadcast(msg);

				//Âú®ËÆ°ÂàíÁöÑÂä®ÁîªÂÆåÊàê‰∫ã‰ª∂ÂêéÂèñÊ∂àÁõëÂê¨, Èò≤Ê≠¢ÂÆ¢Êà∑Á´ØÂõ†ÁâπÊÆäÊÉÖÂÜµÊ≤°ÊúâÂèëÈÄÅÂä®ÁîªÂÆåÊàêÁöÑÊåá‰ª§ÈÄ†ÊàêÊ∞∏‰πÖÁ≠âÂæÖ
				const animationDuration = this.animationStepDuration_ms * (this.dice.getResultNumber() + 5);
				let animationTimer = setTimeout(() => {
					operateListener.emit(player.getId(), OperateType.Animation);
				}, animationDuration);
				await operateListener.onceAsync(player.getId(), OperateType.Animation, () => {
					clearTimeout(animationTimer);
				});
				player.emit(PlayerEvents.AnimationFinished);
			});

			player.addEventListener(PlayerEvents.GainCard, (num: number) => {
				const cardsList = player.getCardsList();
				const addCardsList = this.getRandomChanceCard(num);
				player.setCardsList(cardsList.concat(addCardsList));
			});

			player.addEventListener(PlayerEvents.SetBankrupted, (isBankrupted: boolean) => {
				if (isBankrupted) {
					//Á†¥‰∫ßÂâ•Â§∫Ë¥¢‰∫ß
					Array.from(this.propertyList.values()).map((property) => {
						const owner = property.getOwner();
						if (owner && owner.id === player.getId()) {
							property.setOwner(undefined);
						}
					});
					player.setCardsList([]);
					this.gameOverCheck();
				}
			});
			return player;
		});

		this.currentPlayerInRound = this.playerList[0];
	}

	private getRandomChanceCard(num: number): ChanceCard[] {
		let tempChanceCardList: ChanceCard[] = [];
		for (let i = 0; i < num; i++) {
			const getIndex = Math.floor(Math.random() * this.chanceCardInfoList.length);
			const card = this.chanceCardInfoList[getIndex];
			if (card) tempChanceCardList.push(new ChanceCard(card));
		}
		return tempChanceCardList;
	}

	private gameOverCheck() {
		const gameOverRule = this.gameSetting.gameOverRule;
		switch (gameOverRule) {
			case GameOverRule.Earn100000:
				if (
					this.playerList.some((player) => player.getMoney() >= 100000) ||
					(this.playerList.length === 1 && this.playerList.every((p) => p.getIsBankrupted())) || //‰∏Ä‰∏™‰∫∫Ê∏∏Êàè
					(this.playerList.length > 1 && this.playerList.filter((player) => !player.getIsBankrupted()).length <= 1)
				)
					this.gameOver();
				break;
		}
	}

	public gameInitBroadcast() {
		const {
			id: mapId,
			name: mapName,
			background: mapBackground,
			indexList: mapIndexList,
			itemTypes: itemTypesList,
			streets: streetsList,
		} = this.mapInfo;
		const gameInitInfo: GameInitInfo = {
			mapId: mapId,
			mapName: mapName,
			mapBackground: mapBackground,
			mapItemsList: Array.from(this.mapItemList.values()),
			mapIndexList: mapIndexList,
			itemTypesList: itemTypesList,
			streetsList: streetsList,
			playerList: this.playerList.map((player) => player.getPlayerInfo()),
			properties: Array.from(this.propertyList.values()).map((property) => property.getPropertyInfo()),
			chanceCards: this.chanceCardInfoList,
			currentPlayerInRound: this.currentPlayerInRound ? this.currentPlayerInRound.getId() : "",
			currentRound: this.currentRound,
			currentMultiplier: this.currentMultiplier,
		};

		this.gameBroadcast({
			type: SocketMsgType.GameInit,
			source: "server",
			data: gameInitInfo,
		});
	}

	public gameInfoBroadcast() {
		const gameInfo: GameInfo = {
			currentPlayerInRound: this.currentPlayerInRound ? this.currentPlayerInRound.getId() : "",
			currentRound: this.currentRound,
			currentMultiplier: this.currentMultiplier,
			playerList: this.playerList.map((player) => player.getPlayerInfo()),
			properties: Array.from(this.propertyList.values()).map((property) => property.getPropertyInfo()),
		};
		this.gameBroadcast({
			type: SocketMsgType.GameInfo,
			source: "server",
			data: gameInfo,
		});
	}

	//Á≠âÂæÖÂÖ®ÈÉ®Áé©ÂÆ∂Âä†ËΩΩÂÆåÊàê
	private async waitInitFinished() {
		const promiseArr: Promise<any>[] = [];
		this.playerList.forEach((player) => {
			promiseArr.push(operateListener.onceAsync(player.getId(), OperateType.GameInitFinished, () => {}));
		});
		await Promise.all(promiseArr);

		this.gameBroadcast({ type: SocketMsgType.GameInitFinished, data: "", source: "server" });
	}

	private async gameLoop() {
		this.roundTimeTimer.setIntervalFunction(this.roundRemainingTimeBroadcast);
		while (!this.isGameOver) {
			console.log("üöÄ ~ GameProcess ~ gameLoop ~ this.isGameOver):", this.isGameOver);
			let currentPlayerIndex = 0;
			while (currentPlayerIndex < this.playerList.length) {
				this.gameInfoBroadcast();
				const currentPlayer = this.playerList[currentPlayerIndex];
				if (currentPlayer.getIsBankrupted()) {
					currentPlayerIndex++;
					continue;
				}

				if (currentPlayer.getStop() > 0) {
					this.gameBroadcast({
						type: SocketMsgType.MsgNotify,
						source: "server",
						data: "",
						msg: { content: `${currentPlayer.getName()}Áù°ÁùÄ‰∫Ü,Ë∑≥ËøáÂõûÂêà`, type: "info" },
					});
					currentPlayer.setStop(currentPlayer.getStop() - 1);
					currentPlayerIndex++;
					continue;
				}
				this.currentPlayerInRound = this.playerList[currentPlayerIndex];
				this.roundTurnNotify(this.currentPlayerInRound);
				this.gameInfoBroadcast();

				await this.gameRound(this.currentPlayerInRound);
				currentPlayerIndex++;
			}
			this.nextRound();
		}
		this.roundTimeTimer.clearInterval();
	}

	private async gameRound(currentPlayer: Player) {
		this.roundTimeTimer.setTimeOutFunction(null); //ÂºÄÂßãÂÄíËÆ°Êó∂
		this.useChanceCardListener(currentPlayer);
		await this.waitRollDice(currentPlayer); //ÁõëÂê¨ÊäïÈ™∞Â≠ê
		await this.handleArriveEvent(currentPlayer); //Â§ÑÁêÜÁé©ÂÆ∂Âà∞ËææÊüê‰∏™Ê†ºÂ≠êÁöÑ‰∫ã‰ª∂
	}

	private async useChanceCardListener(sourcePlayer: Player) {
		const userId = sourcePlayer.getId();
		const roundTime = this.gameSetting.roundTime;

		await new Promise(async (resolve, reject) => {
			let roundRemainingTime = roundTime;
			let isRoundEnd = false;
			// let intervalTimer = setInterval(() => {
			// 	this.roundRemainingTimeBroadcast(roundRemainingTime);
			// 	if (roundRemainingTime > 0) {
			// 		roundRemainingTime--;
			// 	} else {
			// 		clearInterval(intervalTimer);
			// 		isRoundEnd = true;
			// 		operateListener.remove(userId, OperateType.RollDice, rollDiceCallBack);
			// 		operateListener.removeAll(userId, OperateType.UseChanceCard);
			// 		operateListener.emit(userId, OperateType.RollDice); //Â∏ÆÁé©ÂÆ∂Ëá™Âä®ÊäïÈ™∞Â≠ê
			// 		resolve("TimeOut");
			// 	}
			// }, 1000);
			// this.intervalTimerList.push(intervalTimer);

			const handleRollDice = () => {
				this.roundTimeTimer.clearTimeout();
				isRoundEnd = true;
				operateListener.removeAll(userId, OperateType.UseChanceCard); //ÂèñÊ∂àÁõëÂê¨Âô®
				resolve("RollDice");
			};

			const handleUseChanceCardTimeOut = () => {
				isRoundEnd = true;
				operateListener.remove(userId, OperateType.RollDice, handleRollDice);
				operateListener.removeAll(userId, OperateType.UseChanceCard);
				operateListener.emit(userId, OperateType.RollDice); //Â∏ÆÁé©ÂÆ∂Ëá™Âä®ÊäïÈ™∞Â≠ê
			};

			//Ë∂ÖÊó∂Ëá™Âä®ÊäïÈ™∞Â≠ê

			//ÊëáÈ™∞Â≠êÂ∞±ÂèñÊ∂àÁõëÂê¨Êú∫‰ºöÂç°ÁöÑ‰ΩøÁî®
			operateListener.once(userId, OperateType.RollDice, handleRollDice);

			while (!isRoundEnd) {
				//ÁõëÂê¨‰ΩøÁî®Êú∫‰ºöÂç°‰∫ã‰ª∂Âπ∂‰∏îÂ§ÑÁêÜ‰∫ã‰ª∂
				this.roundTimeTimer.setTimeOutFunction(handleUseChanceCardTimeOut);
				await operateListener.onceAsync(userId, OperateType.UseChanceCard, async (resultArr: any) => {
					roundRemainingTime = roundTime; //ÈáçÁΩÆÂõûÂêàÂâ©‰ΩôÊó∂Èó¥
					const [chanceCardId, targetIdList = new Array<string>()] = resultArr;
					const chanceCard = sourcePlayer.getCardById(chanceCardId);
					if (chanceCard) {
						let error = ""; //Êî∂ÈõÜÈîôËØØ‰ø°ÊÅØ
						try {
							switch (
								chanceCard.getType() //Ê†πÊçÆÊú∫‰ºöÂç°ÁöÑÁ±ªÂûãÊâßË°å‰∏çÂêåÊìç‰Ωú
							) {
								case ChanceCardType.ToSelf:
									await chanceCard.use(sourcePlayer, sourcePlayer, this); //Áõ¥Êé•‰ΩøÁî®
									this.gameBroadcast(<SocketMessage>{
										type: SocketMsgType.MsgNotify,
										msg: {
											type: "info",
											content: `${sourcePlayer.getName()} ÂØπËá™Â∑±‰ΩøÁî®‰∫ÜÊú∫‰ºöÂç°: "${chanceCard.getName()}"`,
										},
									});
									break;
								case ChanceCardType.ToOtherPlayer:
								case ChanceCardType.ToPlayer:
									const _targetPlayer = this.playerList.find((player) => player.getId() === targetIdList[0]); //Ëé∑ÂèñÁõÆÊ†áÁé©ÂÆ∂ÂØπË±°
									if (!_targetPlayer) {
										error = "ÁõÆÊ†áÁé©ÂÆ∂‰∏çÂ≠òÂú®";
										break;
									}
									await chanceCard.use(sourcePlayer, _targetPlayer, this);
									this.gameBroadcast(<SocketMessage>{
										type: SocketMsgType.MsgNotify,
										msg: {
											type: "info",
											content: `${sourcePlayer.getName()} ÂØπÁé©ÂÆ∂ ${_targetPlayer.getName()} ‰ΩøÁî®‰∫ÜÊú∫‰ºöÂç°: "${chanceCard.getName()}"`,
										},
									});
									break;
								case ChanceCardType.ToProperty:
									const _targetProperty = this.propertyList.get(targetIdList[0]);
									if (!_targetProperty) {
										error = "ÁõÆÊ†áÂª∫Á≠ë/Âú∞ÁöÆ‰∏çÂ≠òÂú®";
										break;
									}
									await chanceCard.use(sourcePlayer, _targetProperty, this);
									this.gameBroadcast(<SocketMessage>{
										type: SocketMsgType.MsgNotify,
										msg: {
											type: "info",
											content: `${sourcePlayer.getName()} ÂØπÂú∞ÁöÆ ${_targetProperty.getName()} ‰ΩøÁî®‰∫ÜÊú∫‰ºöÂç°: "${chanceCard.getName()}"`,
										},
									});
									break;
								case ChanceCardType.ToMapItem:
									const _targetIdList = targetIdList as string[];
									const _targetPlayerList: Player[] = [];
									_targetIdList.forEach((id) => {
										//Ëé∑ÂèñÁõÆÊ†áÁé©ÂÆ∂ÂàóË°®
										const _tempPlayer = this.playerList.find((player) => player.getId() === id);
										if (_tempPlayer) {
											_targetPlayerList.push(_tempPlayer);
										}
									});
									if (_targetPlayerList.length === 0) {
										error = "ÈÄâ‰∏≠ÁöÑÁé©ÂÆ∂‰∏çÂ≠òÂú®";
										break;
									}
									await chanceCard.use(sourcePlayer, _targetPlayerList, this);
									break;
							}
						} catch (e: any) {
							error = e.message;
						}
						if (error) {
							const errorMsg: SocketMessage = {
								type: SocketMsgType.MsgNotify,
								data: "",
								source: "server",
								msg: {
									type: "error",
									content: error,
								},
							};
							sendToUsers([sourcePlayer.getId()], errorMsg);
							const callBackMsg: SocketMessage = {
								type: SocketMsgType.UseChanceCard,
								data: "",
								source: "server",
							};
							sendToUsers([sourcePlayer.getId()], callBackMsg);
						} else {
							sourcePlayer.loseCard(chanceCardId);
							const successMsg: SocketMessage = {
								type: SocketMsgType.MsgNotify,
								data: "",
								source: "server",
								msg: {
									type: "success",
									content: `Êú∫‰ºöÂç° ${chanceCard.getName()} ‰ΩøÁî®ÊàêÂäüÔºÅ`,
								},
							};
							sendToUsers([sourcePlayer.getId()], successMsg);
							const callBackMsg: SocketMessage = {
								type: SocketMsgType.UseChanceCard,
								data: "",
								source: "server",
							};
							sendToUsers([sourcePlayer.getId()], callBackMsg);
						}

						this.gameInfoBroadcast();
					} else {
						const errorMsg: SocketMessage = {
							type: SocketMsgType.MsgNotify,
							data: "",
							source: "server",
							msg: {
								type: "error",
								content: "Êú∫‰ºöÂç°‰ΩøÁî®Â§±Ë¥•: Êú™Áü•ÁöÑÊú∫‰ºöÂç°ID",
							},
						};
						sendToUsers([sourcePlayer.getId()], errorMsg);
					}
				});
			}
		});
	}

	private async waitRollDice(player: Player) {
		const userId = player.getId();
		//Á≠âÂæÖÂÆ¢Êà∑Á´ØÁÇπÂáªÂõûÈ¶à
		await operateListener.onceAsync(userId, OperateType.RollDice, () => {});
		this.gameBroadcast({
			type: SocketMsgType.RollDiceStart,
			source: "server",
			data: "",
		});
		//ÊëáÈ™∞Â≠ê
		this.dice.roll();
		//ËÆ©È™∞Â≠êÊëá‰∏Ä‰ºö :P
		await this.sleep(1500);
		//ÂèëÈÄÅ‰ø°ÊÅØ
		const msgToRollDice: SocketMessage = {
			type: SocketMsgType.RollDiceResult,
			source: "server",
			data: {
				rollDiceResult: this.dice.getResultArray(),
				rollDiceCount: this.dice.getResultNumber(),
				rollDicePlayerId: player.getId(),
			},
			msg: {
				type: "info",
				content: `${player.getUser().username}ÊëáÂà∞ÁöÑÁÇπÊï∞ÊòØ: ${this.dice.getResultArray().join("-")}`,
			},
		};
		//ÈÄöÁü•ÂÖ®ÈÉ®ÂÆ¢Êà∑Á´Ø
		this.gameBroadcast(msgToRollDice);
		//ËÆæÁΩÆÁé©ÂÆ∂ÁöÑ‰ΩçÁΩÆ
		await player.walk(this.dice.getResultNumber());
		//Êõ¥Êñ∞Ê∏∏Êàè‰ø°ÊÅØ
		this.gameInfoBroadcast();
	}

	private async handleArriveEvent(arrivedPlayer: Player) {
		const playerPositionIndex = arrivedPlayer.getPositionIndex();
		const arriveItemId = this.mapInfo.indexList[playerPositionIndex];
		const arriveItem = this.mapItemList.get(arriveItemId);

		if (!arriveItem) return;
		if (arriveItem.linkto) {
			const linkMapItem = arriveItem.linkto;
			if (!linkMapItem.property) return;
			const property = this.propertyList.get(linkMapItem.property.id);
			if (!property) return;
			const arrivePropertyMsg: SocketMessage = {
				type: SocketMsgType.BuyProperty,
				source: "server",
				data: property.getPropertyInfo(),
				msg: {
					type: "",
					content: "",
				},
			};

			// let roundRemainingTime = this.gameSetting.roundTime;
			const owner = property.getOwner();
			if (owner) {
				//Âú∞ÁöÆÊúâ‰∏ª‰∫∫
				if (owner.id === arrivedPlayer.getId()) {
					//Âú∞‰∫ßÊòØËá™Â∑±ÁöÑ
					if (property.getBuildingLevel() < 2) {
						//Ê∑ªÂä†ÂÆöÊó∂Âô®ËÆ°ÁÆóÊìç‰ΩúÂâ©‰ΩôÊó∂Èó¥
						// this.roundRemainingTimeBroadcast(roundRemainingTime);
						// intervalTimer = setInterval(() => {
						// 	this.roundRemainingTimeBroadcast(roundRemainingTime);
						// 	if (roundRemainingTime > 0) {
						// 		roundRemainingTime--;
						// 	} else {
						// 		operateListener.emit(arrivedPlayer.getId(), OperateType.BuildHouse, false);
						// 	}
						// }, 1000);
						// this.intervalTimerList.push(intervalTimer);

						this.roundTimeTimer.setTimeOutFunction(() => {
							operateListener.emit(arrivedPlayer.getId(), OperateType.BuildHouse, false);
						}); //Âà∞Êó∂Èó¥Â∞±ÁªìÊùüÊìç‰Ωú

						//Â∑≤ÊúâÊàø‰∫ß, ÂçáÁ∫ßÊàøÂ±ã
						arrivePropertyMsg.type = SocketMsgType.BuildHouse;
						arrivePropertyMsg.msg = {
							type: "success",
							content: `‰Ω†Âà∞Ëææ‰∫Ü‰Ω†ÁöÑ${property.getName()}ÔºåÂèØ‰ª•ÂçáÁ∫ßÊàøÂ≠ê`,
						};
						sendToUsers([arrivedPlayer.getId()], arrivePropertyMsg);
						const playerRes = await operateListener.onceAsync(
							arrivedPlayer.getId(),
							OperateType.BuildHouse,
							(data) => data[0]
						);
						this.roundRemainingTimeBroadcast(0);
						if (playerRes) {
							this.handlePlayerBuildUp(arrivedPlayer, property);
						}
					}
				} else {
					//Âú∞‰∫ßÊòØÂà´‰∫∫ÁöÑ
					const ownerPlayer = this.getPlayerById(owner.id);
					if (!ownerPlayer) return;
					const passCost = property.getPassCost() * this.currentMultiplier;
					this.handlePayToSomeOne(arrivedPlayer, ownerPlayer, passCost);
					arrivePropertyMsg.type = SocketMsgType.MsgNotify;
					arrivePropertyMsg.msg = {
						type: "error",
						content: `‰Ω†Âà∞Ëææ‰∫Ü${owner.name}ÁöÑ${property.getName()}ÔºåÊîØ‰ªò‰∫Ü${passCost}Ôø•ËøáË∑ØË¥π`,
					};
					sendToUsers([arrivedPlayer.getId()], arrivePropertyMsg);
					arrivePropertyMsg.msg = {
						type: "success",
						content: `${arrivedPlayer.getName()}Âà∞Ëææ‰∫Ü‰Ω†ÁöÑ${property.getName()}ÔºåÊîØ‰ªò‰∫Ü${passCost}Ôø•ËøáË∑ØË¥π`,
					};
					sendToUsers([ownerPlayer.getId()], arrivePropertyMsg);
				}
			} else {
				//Âú∞ÁöÆÊ≤°Êúâ‰∏ª‰∫∫
				//Ê∑ªÂä†ÂÆöÊó∂Âô®ËÆ°ÁÆóÊìç‰ΩúÂâ©‰ΩôÊó∂Èó¥
				// this.roundRemainingTimeBroadcast(roundRemainingTime);
				// intervalTimer = setInterval(() => {
				// 	this.roundRemainingTimeBroadcast(roundRemainingTime);
				// 	if (roundRemainingTime > 0) {
				// 		roundRemainingTime--;
				// 	} else {
				// 		operateListener.emit(arrivedPlayer.getId(), OperateType.BuyProperty, false);
				// 	}
				// }, 1000);
				this.roundTimeTimer.setTimeOutFunction(() => {
					operateListener.emit(arrivedPlayer.getId(), OperateType.BuyProperty, false);
				}); //Âà∞Êó∂Èó¥Â∞±ÁªìÊùüÊìç‰Ωú

				//Âú∞ÁöÆÊ≤°ÊúâË¥≠‰π∞
				arrivePropertyMsg.type = SocketMsgType.BuyProperty;
				arrivePropertyMsg.msg = {
					type: "success",
					content: `‰Ω†Âà∞Ëææ‰∫Ü${property.getName()}ÔºåÂèØ‰ª•‰π∞‰∏ãËøôÂùóÂú∞ÁöÆ`,
				};
				//Á©∫Âú∞, ‰π∞Êàø
				sendToUsers([arrivedPlayer.getId()], arrivePropertyMsg);
				//Á≠âÂæÖÂÆ¢Êà∑Á´ØÂõûÂ∫î‰π∞Êàø
				const playerRes = await operateListener.onceAsync(
					arrivedPlayer.getId(),
					OperateType.BuyProperty,
					(data) => data[0]
				);
				this.roundRemainingTimeBroadcast(0);
				if (playerRes) {
					this.handlePlayerBuyProperty(arrivedPlayer, property);
				}
			}
		} else if (arriveItem.arrivedEvent) {
			const effectCode = arriveItem.arrivedEvent.effectCode;
			effectCode && new Function("arrivedPlayer", effectCode)(arrivedPlayer);
		}
		this.gameInfoBroadcast();
	}

	private getPlayerById(id: string) {
		return this.playerList.find((player) => player.getId() === id);
	}

	private handlePayToSomeOne(source: Player, target: Player, money: number) {
		target.gain(money);
		return source.cost(money);
	}

	private nextRound() {
		this.currentRound++;
		this.gameOverCheck();
		if (this.currentRound % this.gameSetting.multiplierIncreaseRounds === 0) {
			this.currentMultiplier += this.gameSetting.multiplier;
		}
	}

	private handlePlayerBuyProperty(player: Player, property: Property) {
		const msgToSend: SocketMessage = {
			type: SocketMsgType.MsgNotify,
			source: "server",
			data: "",
			msg: {
				type: "",
				content: "",
			},
		};
		if (player.getMoney() > property.getSellCost()) {
			if (player.cost(property.getSellCost())) {
				property.setOwner(player);
				msgToSend.msg = { type: "success", content: `Ë¥≠‰π∞ ${property.getName()} ÊàêÂäüÔºÅ` };
			} else {
				msgToSend.msg = { type: "warning", content: "‰π∞ÂÆåÂ∞±Ê≤°Èí±ÂíØ" };
			}
		} else {
			msgToSend.msg = { type: "error", content: "‰∏çÂ§üÈí±ÂïäÁ©∑È¨º" };
		}
		sendToUsers([player.getId()], msgToSend);
		return;
	}

	private roundTurnNotify(player: Player) {
		const msgToSend: SocketMessage = {
			type: SocketMsgType.RoundTurn,
			source: "server",
			data: "",
			msg: {
				type: "info",
				content: "Áé∞Âú®ÊòØ‰Ω†ÁöÑÂõûÂêàÂï¶ÔºÅ",
			},
		};
		sendToUsers([player.getId()], msgToSend);
	}

	public roundRemainingTimeBroadcast = (remainingTime: number) => {
		const msg: SocketMessage = {
			type: SocketMsgType.RemainingTime,
			source: "server",
			data: remainingTime,
		};
		this.gameBroadcast(msg);
	};

	private handlePlayerBuildUp(player: Player, property: Property) {
		const msgToSend: SocketMessage = {
			type: SocketMsgType.MsgNotify,
			source: "server",
			data: "",
			msg: {
				type: "",
				content: "",
			},
		};
		if (player.getMoney() > property.getSellCost()) {
			if (player.cost(property.getBuildCost())) {
				property.buildUp();
				msgToSend.msg = { type: "success", content: `BuildUP ${property.getName()} ÊàêÂäüÔºÅ` };
			} else {
				msgToSend.msg = { type: "warning", content: "ÂçáÁ∫ßÂÆåÂ∞±Ê≤°Èí±ÂíØ" };
			}
		} else {
			msgToSend.msg = { type: "error", content: "‰∏çÂ§üÈí±ÂïäÁ©∑È¨º" };
		}
		sendToUsers([player.getId()], msgToSend);
		return;
	}

	public handlePlayerOffline(userId: string) {
		const player = this.getPlayerById(userId);
		if (player) {
			player.setIsOffline(true);
			this.gameInfoBroadcast();
		}
	}

	public handlePlayerReconnect(userId: string) {
		const player = this.playerList.find((player) => player.getUser().userId === userId);
		if (player) {
			player.setIsOffline(false);
			const {
				id: mapId,
				name: mapName,
				background: mapBackground,
				indexList: mapIndexList,
				itemTypes: itemTypesList,
				streets: streetsList,
			} = this.mapInfo;
			const gameInitInfo: GameInitInfo = {
				mapId: mapId,
				mapName: mapName,
				mapBackground: mapBackground,
				mapItemsList: Array.from(this.mapItemList.values()),
				mapIndexList: mapIndexList,
				itemTypesList: itemTypesList,
				streetsList: streetsList,
				playerList: this.playerList.map((player) => player.getPlayerInfo()),
				properties: Array.from(this.propertyList.values()).map((property) => property.getPropertyInfo()),
				chanceCards: this.chanceCardInfoList,
				currentPlayerInRound: this.currentPlayerInRound ? this.currentPlayerInRound.getId() : "",
				currentRound: this.currentRound,
				currentMultiplier: this.currentMultiplier,
			};
			sendToUsers([userId], <SocketMessage>{
				type: SocketMsgType.GameInit,
				source: "server",
				data: gameInitInfo,
			});
			operateListener.once(player.getId(), OperateType.GameInitFinished, () => {
				sendToUsers([userId], <SocketMessage>{
					type: SocketMsgType.GameInitFinished,
					data: "",
					source: "server",
				});
			});
			this.gameInfoBroadcast();
		} else {
			console.log("Â•áÊÄ™ÁöÑÁé©ÂÆ∂ in game");
		}
	}

	private sleep(ms: number) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}

	private gameOver() {
		this.gameInfoBroadcast();
		this.gameBroadcast({
			type: SocketMsgType.GameOver,
			source: "server",
			data: "Ê∏∏ÊàèÁªìÊùü",
			msg: { content: "Ê∏∏ÊàèÁªìÊùü", type: "info" },
		});
		self.postMessage(<WorkerCommMsg>{
			type: WorkerCommType.GameOver,
		});
		this.isGameOver = true;
		this.destroy();
	}

	public gameMsgNotifyBroadcast(type: "success" | "warning" | "error" | "info", msg: string) {
		this.gameBroadcast({
			type: SocketMsgType.MsgNotify,
			data: "",
			msg: { type, content: msg },
			source: "server",
		});
	}

	public gameBroadcast(msg: SocketMessage) {
		sendToUsers(
			this.playerList.map((u) => u.getId()),
			msg
		);
	}

	public destroy() {
		this.isGameOver = true;
		this.playerList.forEach((p) => {
			operateListener.removeAll(p.getId());
		});
		this.intervalTimerList.forEach((id) => {
			clearInterval(id);
		});
		this.timeoutList.forEach((id) => {
			clearTimeout(id);
		});
	}
}
